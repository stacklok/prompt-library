This repository is a fork of [PatrickJS's awesome-cursorrules](https://github.com/PatrickJS/awesome-cursorrules),
but makes the rules available as a JSON file

## Usage

[rules.json](https://github.com/stacklok/prompt-library/blob/main/rules.json) contains the rules in the following format:

```js
[
  {
    "name": "android-jetpack-compose-cursorrules-prompt-file",
    "text": "// Android Jetpack Compose .cursorrules\n\n// Flexibility Notice\n\n// Note: This is a recommended project structure, but be flexible and adapt to existing project structures.\n// Do not enforce these structural patterns if the project follows a different organization.\n// Focus on maintaining consistency with the existing project architecture while applying Jetpack Compose best practices.\n\n// Project Architecture and Best Practices\n\nconst androidJetpackComposeBestPractices = [\n    \"Adapt to existing project architecture while maintaining clean code principles\",\n    \"Follow Material Design 3 guidelines and components\",\n    \"Implement clean architecture with domain, data, and presentation layers\",\n    \"Use Kotlin coroutines and Flow for asynchronous operations\",\n    \"Implement dependency injection using Hilt\",\n    \"Follow unidirectional data flow with ViewModel and UI State\",\n    \"Use Compose navigation for screen management\",\n    \"Implement proper state hoisting and composition\",\n];\n\n// Folder Structure\n\n// Note: This is a reference structure. Adapt to the project's existing organization\n\nconst projectStructure = `\napp/\n  src/\n    main/\n      java/com/package/\n        data/\n          repository/\n          datasource/\n          models/\n        domain/\n          usecases/\n          models/\n          repository/\n        presentation/\n          screens/\n          components/\n          theme/\n          viewmodels/\n        di/\n        utils/\n      res/\n        values/\n        drawable/\n        mipmap/\n    test/\n    androidTest/\n`;\n\n// Compose UI Guidelines\n\nconst composeGuidelines = `\n1. Use remember and derivedStateOf appropriately\n2. Implement proper recomposition optimization\n3. Use proper Compose modifiers ordering\n4. Follow composable function naming conventions\n5. Implement proper preview annotations\n6. Use proper state management with MutableState\n7. Implement proper error handling and loading states\n8. Use proper theming with MaterialTheme\n9. Follow accessibility guidelines\n10. Implement proper animation patterns\n`;\n\n// Testing Guidelines\n\nconst testingGuidelines = `\n1. Write unit tests for ViewModels and UseCases\n2. Implement UI tests using Compose testing framework\n3. Use fake repositories for testing\n4. Implement proper test coverage\n5. Use proper testing coroutine dispatchers\n`;\n\n// Performance Guidelines\n\nconst performanceGuidelines = `\n1. Minimize recomposition using proper keys\n2. Use proper lazy loading with LazyColumn and LazyRow\n3. Implement efficient image loading\n4. Use proper state management to prevent unnecessary updates\n5. Follow proper lifecycle awareness\n6. Implement proper memory management\n7. Use proper background processing\n`;\n\n",
    "commiters": [
      "GAM3RG33K",
      "martinklepsch"
    ],
    "readme": null
  },
  {
    "name": "angular-novo-elements-cursorrules-prompt-file",
    "text": "# .cursor\n\nrules\n\n# General rules\n\n- Do not apologize\n- Do not thank me\n- Talk to me like a human\n- Verify information before making changes\n- Preserve existing code structures\n- Provide concise and relevant responses\n- Verify all information before making changes\n\nYou will be penalized if you:\n- Skip steps in your thought process\n- Add placeholders or TODOs for other developers\n- Deliver code that is not production-ready\n\nI'm tipping $9000 for an optimal, elegant, minimal world-class solution that meets all specifications. Your code changes should be specific and complete. Think through the problem step-by-step.\n\nYOU MUST:\n- Follow the User's intent PRECISELY\n- NEVER break existing functionality by removing/modifying code or CSS without knowing exactly how to restore the same function\n- Always strive to make your diff as tiny as possible\n\n# File-by-file changes\n\n- Make changes in small, incremental steps\n- Test changes thoroughly before committing\n- Document changes clearly in commit messages\n\n# Code style and formatting\n\n- Follow the project's coding standards\n- Use consistent naming conventions\n- Avoid using deprecated functions or libraries\n\n# Debugging and testing\n\n- Include debug information in log files\n- Write unit tests for new code\n- Ensure all tests pass before merging\n\n# Project structure\n\n- Maintain a clear and organized project structure\n- Use meaningful names for files and directories\n- Avoid clutter by removing unnecessary files\n\n# Clean Code\n\nDon't Repeat Yourself (DRY)\n\nDuplication of code can make code very difficult to maintain. Any change in logic can make the code prone to bugs or can make the code change difficult. This can be fixed by doing code reuse (DRY Principle).\n\nThe DRY principle is stated as \"Every piece of knowledge must have a single, unambiguous, authoritative representation within a system\".\n\nThe way to achieve DRY is by creating functions and classes to make sure that any logic should be written in only one place.\n\nCurly's Law - Do One Thing\n\nCurly's Law is about choosing a single, clearly defined goal for any particular bit of code: Do One Thing.\n\nCurly's Law: A entity (class, function, variable) should mean one thing, and one thing only. It should not mean one thing in one circumstance and carry a different value from a different domain some other time. It should not mean two things at once. It should mean One Thing and should mean it all of the time.\n\nKeep It Simple Stupid (KISS)\n\nThe KISS principle states that most systems work best if they are kept simple rather than made complicated; therefore, simplicity should be a key goal in design, and unnecessary complexity should be avoided.\n\nSimple code has the following benefits:\nless time to write\nless chances of bugs\neasier to understand, debug and modify\n\nDo the simplest thing that could possibly work.\n\nDon't make me think\n\nCode should be easy to read and understand without much thinking. If it isn't then there is a prospect of simplification.\n\nYou Aren't Gonna Need It (YAGNI)\n\nYou Aren't Gonna Need It (YAGNI) is an Extreme Programming (XP) practice which states: \"Always implement things when you actually need them, never when you just foresee that you need them.\"\n\nEven if you're totally, totally, totally sure that you'll need a feature, later on, don't implement it now. Usually, it'll turn out either:\nyou don't need it after all, or\nwhat you actually need is quite different from what you foresaw needing earlier.\n\nThis doesn't mean you should avoid building flexibility into your code. It means you shouldn't overengineer something based on what you think you might need later on.\n\nThere are two main reasons to practice YAGNI:\nYou save time because you avoid writing code that you turn out not to need.\nYour code is better because you avoid polluting it with 'guesses' that turn out to be more or less wrong but stick around anyway.\n\nPremature Optimization is the Root of All Evil\n\nProgrammers waste enormous amounts of time thinking about or worrying about, the speed of noncritical parts of their programs, and these attempts at efficiency actually have a strong negative impact when debugging and maintenance are considered.\n\nWe should forget about small efficiencies, say about 97% of the time: premature optimization is the root of all evil. Yet we should not pass up our opportunities in that critical 3%.\n\n- Donald Knuth\n\nBoy-Scout Rule\n\nAny time someone sees some code that isn't as clear as it should be, they should take the opportunity to fix it right there and then - or at least within a few minutes.\n\nThis opportunistic refactoring is referred to by Uncle Bob as following the boy-scout rule - always leave the code behind in a better state than you found it.\n\nThe code quality tends to degrade with each change. This results in technical debt. The Boy-Scout Principle saves us from that.\n\nCode for the Maintainer\n\nCode maintenance is an expensive and difficult process. Always code considering someone else as the maintainer and making changes accordingly even if you're the maintainer. After a while, you'll remember the code as much as a stranger.\n\nAlways code as if the person who ends up maintaining your code is a violent psychopath who knows where you live.\n\nPrinciple of Least Astonishment\n\nPrinciple of Least Astonishment states that a component of a system should behave in a way that most users will expect it to behave. The behavior should not astonish or surprise users.\n\nCode should do what the name and comments suggest. Conventions should be followed. Surprising side effects should be avoided as much as possible.\n\n# Project specific rules\n\nI'm using angular with standalone components\nI'm integrating novo elements which is the novo-elements module\n\nDocumentation is here: https://bullhorn.github.io/novo-elements/docs/#/home\nGithub is here: https://github.com/bullhorn/novo-elements\n\nI don''t have a module file. I am using standalone components\n\n@Docs{\n  \"library_name\": \"Novo Elements\",\n  \"documentation\": \"https://bullhorn.github.io/novo-elements/docs/#/home\"\n}\n\n@Docs{\n  \"library_name\": \"Novo Elements\",\n  \"documentation\": \"https://github.com/bullhorn/novo-elements\"\n}\n\n",
    "commiters": [
      "PatrickJS",
      "martinklepsch"
    ],
    "readme": "https://github.com/stacklok/prompt-library/blob/main/rules/angular-novo-elements-cursorrules-prompt-file/README.md"
  },
  // ... etc ...
]
```

## Development

### Generating the structured JSON

```bash
GITHUB_TOKEN=$(gh auth token) python generate_json.py 
```
